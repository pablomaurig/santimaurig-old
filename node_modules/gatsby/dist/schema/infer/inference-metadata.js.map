{"version":3,"sources":["../../../src/schema/infer/inference-metadata.js"],"names":["groupBy","isEqual","require","is32BitInteger","looksLikeADate","getType","value","key","Date","String","Array","isArray","length","includes","Object","keys","updateValueDescriptor","nodeId","operation","descriptor","path","typeName","push","ret","_updateValueDescriptor","pop","delta","typeInfo","total","dirty","first","undefined","props","forEach","v","propDescriptor","propDirty","item","itemDescriptor","itemDirty","nodes","empty","example","mergeObjectKeys","obj","other","otherProps","Set","concat","descriptorsAreEqual","otherDescriptor","types","possibleTypes","otherTypes","array","object","every","prop","nodeFields","node","ignoredFields","filter","has","updateTypeMetadata","metadata","initialMetadata","disabled","ignored","fieldMap","structureChanged","field","valueStructureChanged","id","ignore","set","disable","addNode","deleteNode","addNodes","reduce","isMixedNumber","float","int","isMixOfDateAndString","date","string","hasOnlyEmptyStrings","type","resolveWinnerType","candidates","prepareConflictExamples","isArrayItem","typeNameMapper","reportedValueMapper","listOfUnion","getExampleObject","itemValue","buildExampleValue","conflictingTypes","groups","map","join","typeConflictReporter","conflicts","addConflict","exampleItemValue","hasKeys","result","acc","isEmpty","hasNodes","typeMetadata","haveEqualFields","otherFieldMap","fields","state","module","exports"],"mappings":"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","sourcesContent":["/*\n## Incrementally track the structure of nodes with metadata\n\nThis metadata can be later utilized for schema inference\n(via building `exampleValue` or directly)\n\n### Usage example:\n\n```javascript\n  const node1 = { id: '1', foo: 25, bar: 'str' }\n  const node2 = { id: '1', foo: 'conflict' }\n\n  let meta = { ignoredFields: new Set(['id']) }\n  meta = addNode(meta, node1)\n  meta = addNode(meta, node2)\n  console.log(meta.fieldMap)\n  // outputs: {\n  //   foo: {\n  //     int: { total: 1, example: 25 },\n  //     string: { total: 1, example: 'conflict' },\n  //   },\n  //   bar: {\n  //     string: { total: 1, example: 'str' },\n  //   },\n  // }\n\n  const example1 = getExampleObject({ meta, typeName, typeConflictReporter })\n  console.log(example1)\n  // outputs { bar: 'str' }\n  // and reports conflicts discovered\n\n  meta = deleteNode(meta, node2)\n  console.log(meta.fieldMap)\n  // outputs: {\n  //   foo: {\n  //     int: { total: 1, example: 25 },\n  //     string: { total: 0, example: 'conflict' },\n  //   },\n  //   bar: { string: { total: 1, example: 'str' } },\n  // }\n\n  const example2 = getExampleObject({ meta, typeName, typeConflictReporter })\n  // outputs: { foo: 25, bar: 'str' }\n```\n\n`addNode`, `deleteNode`, `getExampleObject` are O(N) where N is the number\nof fields in the node object (including nested fields)\n\n### Metadata structure\n\n```javascript\ntype TypeMetadata = {\n  total?: number,\n  ignored?: boolean,\n  ignoredFields?: Set<string>,\n  fieldMap?: { [string]: ValueDescriptor },\n  typeName?: string,\n  dirty?: boolean, // tracks structural changes only\n  disabled?: boolean,\n}\n\ntype Count = number\ntype NodeId = string\n\ntype ValueDescriptor = {\n  int?: { total: Count, first: NodeId, example: number },\n  float?: { total: Count, first: NodeId, example: number },\n  date?: { total: Count, first: NodeId, example: string },\n  string?: { total: Count, first: NodeId, example: string, empty: Count },\n  boolean?: { total: Count, first: NodeId, example: boolean },\n  array?: { total: Count, first: NodeId, item: ValueDescriptor },\n  listOfUnion?: { total: Count, first: NodeId, nodes: { [NodeId]: Count } },\n  object?: { total: 0, first: NodeId, props: { [string]: ValueDescriptor } },\n}\n```\n\n### Caveats\n\n* Conflict tracking for arrays is tricky, i.e.: { a: [5, \"foo\"] } and { a: [5] }, { a: [\"foo\"] }\n  are represented identically in metadata. To workaround it we additionally track first NodeId:\n  { a: { array: { item: { int: { total: 1, first: `1` }, string: { total: 1, first: `1` } }}\n  { a: { array: { item: { int: { total: 1, first: `1` }, string: { total: 1, first: `2` } }}\n  This way we can produce more useful conflict reports\n  (still rare edge cases possible when reporting may be confusing, i.e. when node is deleted)\n*/\n\nconst { groupBy, isEqual } = require(`lodash`)\nconst is32BitInteger = require(`./is-32-bit-integer`)\nconst { looksLikeADate } = require(`../types/date`)\n\nconst getType = (value, key) => {\n  // Staying as close as possible to GraphQL types\n  switch (typeof value) {\n    case `number`:\n      return is32BitInteger(value) ? `int` : `float`\n    case `string`:\n      return looksLikeADate(value) ? `date` : `string`\n    case `boolean`:\n      return `boolean`\n    case `object`:\n      if (value === null) return `null`\n      if (value instanceof Date) return `date`\n      if (value instanceof String) return `string`\n      if (Array.isArray(value)) {\n        if (value.length === 0) {\n          return `null`\n        }\n        return key.includes(`___NODE`) ? `listOfUnion` : `array`\n      }\n      if (!Object.keys(value).length) return `null`\n      return `object`\n    default:\n      return `null`\n  }\n}\n\nconst updateValueDescriptor = (\n  { nodeId, key, value, operation = `add` /*: add | del*/, descriptor = {} },\n  path = []\n) => {\n  // The object may be traversed multiple times from root.\n  // Each time it does it should not revisit the same node twice\n  if (path.includes(value)) {\n    return [descriptor, false]\n  }\n\n  const typeName = getType(value, key)\n\n  if (typeName === `null`) {\n    return [descriptor, false]\n  }\n\n  path.push(value)\n\n  const ret = _updateValueDescriptor(\n    nodeId,\n    key,\n    value,\n    operation,\n    descriptor,\n    path,\n    typeName\n  )\n\n  path.pop()\n\n  return ret\n}\nconst _updateValueDescriptor = (\n  nodeId,\n  key,\n  value,\n  operation,\n  descriptor,\n  path,\n  typeName\n) => {\n  const delta = operation === `del` ? -1 : 1\n  const typeInfo = descriptor[typeName] || { total: 0 }\n  typeInfo.total += delta\n\n  // Keeping track of structural changes\n  // (when value of a new type is added or an existing type has no more values assigned)\n  let dirty =\n    typeInfo.total === 0 || (operation === `add` && typeInfo.total === 1)\n\n  // Keeping track of the first node for this type. Only used for better conflict reporting.\n  // (see Caveats section in the header comments)\n  if (operation === `add`) {\n    if (!typeInfo.first) {\n      typeInfo.first = nodeId\n    }\n  } else if (operation === `del`) {\n    if (typeInfo.first === nodeId || typeInfo.total === 0) {\n      typeInfo.first = undefined\n    }\n  }\n\n  switch (typeName) {\n    case `object`: {\n      const { props = {} } = typeInfo\n      Object.keys(value).forEach(key => {\n        const v = value[key]\n\n        const [propDescriptor, propDirty] = updateValueDescriptor(\n          {\n            nodeId,\n            key,\n            value: v,\n            operation,\n            descriptor: props[key],\n          },\n          path\n        )\n        props[key] = propDescriptor\n        dirty = dirty || propDirty\n      })\n      typeInfo.props = props\n      break\n    }\n    case `array`: {\n      value.forEach(item => {\n        const [itemDescriptor, itemDirty] = updateValueDescriptor(\n          {\n            nodeId,\n            descriptor: typeInfo.item,\n            operation,\n            value: item,\n            key,\n          },\n          path\n        )\n\n        typeInfo.item = itemDescriptor\n        dirty = dirty || itemDirty\n      })\n      break\n    }\n    case `listOfUnion`: {\n      const { nodes = {} } = typeInfo\n      value.forEach(nodeId => {\n        nodes[nodeId] = (nodes[nodeId] || 0) + delta\n\n        // Treat any new related node addition or removal as a structural change\n        // FIXME: this will produce false positives as this node can be\n        //  of the same type as another node already in the map (but we don't know it)\n        dirty = dirty || nodes[nodeId] === 0 || nodes[nodeId] === 1\n      })\n      typeInfo.nodes = nodes\n      break\n    }\n    case `string`: {\n      if (value === ``) {\n        const { empty = 0 } = typeInfo\n        typeInfo.empty = empty + delta\n      }\n      typeInfo.example =\n        typeof typeInfo.example !== `undefined` ? typeInfo.example : value\n      break\n    }\n    default:\n      typeInfo.example =\n        typeof typeInfo.example !== `undefined` ? typeInfo.example : value\n      break\n  }\n  descriptor[typeName] = typeInfo\n  return [descriptor, dirty]\n}\n\nconst mergeObjectKeys = (obj, other) => {\n  const props = Object.keys(obj)\n  const otherProps = Object.keys(other)\n  return [...new Set(props.concat(otherProps))]\n}\n\nconst descriptorsAreEqual = (descriptor, otherDescriptor) => {\n  const types = possibleTypes(descriptor)\n  const otherTypes = possibleTypes(otherDescriptor)\n\n  // Empty are equal\n  if (types.length === 0 && otherTypes.length === 0) {\n    return true\n  }\n  // Conflicting and non-matching types are not equal\n  // TODO: consider descriptors with equal conflicts as equal?\n  if (types.length > 1 || otherTypes.length > 1 || types[0] !== otherTypes[0]) {\n    return false\n  }\n  switch (types[0]) {\n    case `array`:\n      return descriptorsAreEqual(\n        descriptor.array.item,\n        otherDescriptor.array.item\n      )\n    case `object`: {\n      const props = mergeObjectKeys(\n        descriptor.object.props,\n        otherDescriptor.object.props\n      )\n      return props.every(prop =>\n        descriptorsAreEqual(\n          descriptor.object.props[prop],\n          otherDescriptor.object.props[prop]\n        )\n      )\n    }\n    case `listOfUnion`: {\n      return isEqual(descriptor.nodes, otherDescriptor.nodes)\n    }\n    default:\n      return true\n  }\n}\n\nconst nodeFields = (node, ignoredFields = new Set()) =>\n  Object.keys(node).filter(key => !ignoredFields.has(key))\n\nconst updateTypeMetadata = (metadata = initialMetadata(), operation, node) => {\n  if (metadata.disabled) {\n    return metadata\n  }\n  metadata.total = (metadata.total || 0) + (operation === `add` ? 1 : -1)\n  if (metadata.ignored) {\n    return metadata\n  }\n  const { ignoredFields, fieldMap = {}, dirty = false } = metadata\n\n  let structureChanged = false\n  nodeFields(node, ignoredFields).forEach(field => {\n    const [descriptor, valueStructureChanged] = updateValueDescriptor({\n      nodeId: node.id,\n      key: field,\n      value: node[field],\n      operation,\n      descriptor: fieldMap[field],\n    })\n    fieldMap[field] = descriptor\n    structureChanged = structureChanged || valueStructureChanged\n  })\n  metadata.fieldMap = fieldMap\n  metadata.dirty = dirty || structureChanged\n  return metadata\n}\n\nconst ignore = (metadata = initialMetadata(), set = true) => {\n  metadata.ignored = set\n  metadata.fieldMap = {}\n  return metadata\n}\n\nconst disable = (metadata = initialMetadata(), set = true) => {\n  metadata.disabled = set\n  return metadata\n}\n\nconst addNode = (metadata, node) => updateTypeMetadata(metadata, `add`, node)\nconst deleteNode = (metadata, node) => updateTypeMetadata(metadata, `del`, node)\nconst addNodes = (metadata = initialMetadata(), nodes) =>\n  nodes.reduce(addNode, metadata)\n\nconst isMixedNumber = ({ float, int }) =>\n  float && float.total > 0 && int && int.total > 0\n\nconst isMixOfDateAndString = ({ date, string }) =>\n  date && date.total > 0 && string && string.total > 0\n\nconst hasOnlyEmptyStrings = ({ string }) =>\n  string && string.empty === string.total\n\nconst possibleTypes = (descriptor = {}) =>\n  Object.keys(descriptor).filter(type => descriptor[type].total > 0)\n\nconst resolveWinnerType = descriptor => {\n  const candidates = possibleTypes(descriptor)\n  if (candidates.length === 1) {\n    return [candidates[0]]\n  }\n  if (candidates.length === 2 && isMixedNumber(descriptor)) {\n    return [`float`]\n  }\n  if (candidates.length === 2 && isMixOfDateAndString(descriptor)) {\n    return [hasOnlyEmptyStrings(descriptor) ? `date` : `string`]\n  }\n  if (candidates.length > 1) {\n    return [`null`, true]\n  }\n  return [`null`]\n}\n\nconst prepareConflictExamples = (descriptor, isArrayItem) => {\n  const typeNameMapper = typeName => {\n    if (typeName === `listOfUnion`) {\n      return `[string]`\n    }\n    return [`float`, `int`].includes(typeName) ? `number` : typeName\n  }\n  const reportedValueMapper = typeName => {\n    if (typeName === `listOfUnion`) {\n      const { nodes } = descriptor.listOfUnion\n      return Object.keys(nodes).filter(key => nodes[key] > 0)\n    }\n    if (typeName === `object`) {\n      return getExampleObject({ typeName, fieldMap: descriptor.object.props })\n    }\n    if (typeName === `array`) {\n      const itemValue = buildExampleValue({\n        descriptor: descriptor.array.item,\n        isArrayItem: true,\n      })\n      return itemValue === null || itemValue === undefined ? [] : [itemValue]\n    }\n    return descriptor[typeName].example\n  }\n  const conflictingTypes = possibleTypes(descriptor)\n\n  if (isArrayItem) {\n    // Differentiate conflict examples by node they were first seen in.\n    // See Caveats section in the header of this file\n    const groups = groupBy(\n      conflictingTypes,\n      type => descriptor[type].first || ``\n    )\n    return Object.keys(groups).map(nodeId => {\n      return {\n        type: `[${groups[nodeId].map(typeNameMapper).join(`,`)}]`,\n        value: groups[nodeId].map(reportedValueMapper),\n      }\n    })\n  }\n\n  return conflictingTypes.map(type => {\n    return {\n      type: typeNameMapper(type),\n      value: reportedValueMapper(type),\n    }\n  })\n}\n\nconst buildExampleValue = ({\n  descriptor,\n  typeConflictReporter,\n  isArrayItem = false,\n  path = ``,\n}) => {\n  const [type, conflicts = false] = resolveWinnerType(descriptor)\n\n  if (conflicts && typeConflictReporter) {\n    typeConflictReporter.addConflict(\n      path,\n      prepareConflictExamples(descriptor, isArrayItem)\n    )\n  }\n\n  const typeInfo = descriptor[type]\n\n  switch (type) {\n    case `null`:\n      return null\n\n    case `date`:\n    case `string`: {\n      if (isMixOfDateAndString(descriptor)) {\n        return hasOnlyEmptyStrings(descriptor) ? `1978-09-26` : `String`\n      }\n      return typeInfo.example\n    }\n\n    case `array`: {\n      const { item } = typeInfo\n      const exampleItemValue = item\n        ? buildExampleValue({\n            descriptor: item,\n            isArrayItem: true,\n            typeConflictReporter,\n            path,\n          })\n        : null\n      return exampleItemValue === null ? null : [exampleItemValue]\n    }\n\n    case `listOfUnion`: {\n      const { nodes = {} } = typeInfo\n      return Object.keys(nodes).filter(key => nodes[key] > 0)\n    }\n\n    case `object`: {\n      const { props } = typeInfo\n      let hasKeys = false\n      const result = {}\n      Object.keys(props).forEach(prop => {\n        const value = buildExampleValue({\n          descriptor: typeInfo.props[prop],\n          typeConflictReporter,\n          path: `${path}.${prop}`,\n        })\n        if (value !== null) {\n          hasKeys = true\n          result[prop] = value\n        }\n      }, {})\n      return hasKeys ? result : null\n    }\n\n    default:\n      return typeInfo.example\n  }\n}\n\nconst getExampleObject = ({ fieldMap = {}, typeName, typeConflictReporter }) =>\n  Object.keys(fieldMap).reduce((acc, key) => {\n    const value = buildExampleValue({\n      path: `${typeName}.${key}`,\n      descriptor: fieldMap[key],\n      typeConflictReporter,\n    })\n    if (key && value !== null) {\n      acc[key] = value\n    }\n    return acc\n  }, {})\n\nconst isEmpty = ({ fieldMap }) =>\n  Object.keys(fieldMap).every(\n    field => possibleTypes(fieldMap[field]).length === 0\n  )\n\n// Even empty type may still have nodes\nconst hasNodes = typeMetadata => typeMetadata.total > 0\n\nconst haveEqualFields = (\n  { fieldMap = {} } = {},\n  { fieldMap: otherFieldMap = {} } = {}\n) => {\n  const fields = mergeObjectKeys(fieldMap, otherFieldMap)\n  return fields.every(field =>\n    descriptorsAreEqual(fieldMap[field], otherFieldMap[field])\n  )\n}\n\nconst initialMetadata = state => {\n  return {\n    typeName: undefined,\n    disabled: false,\n    ignored: false,\n    dirty: false,\n    total: 0,\n    ignoredFields: undefined,\n    fieldMap: {},\n    ...state,\n  }\n}\n\nmodule.exports = {\n  addNode,\n  addNodes,\n  deleteNode,\n  ignore,\n  disable,\n  isEmpty,\n  hasNodes,\n  haveEqualFields,\n  getExampleObject,\n  initialMetadata,\n}\n"],"file":"inference-metadata.js"}